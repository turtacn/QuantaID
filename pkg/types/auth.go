package types

import (
	"github.com/golang-jwt/jwt/v4"
	"time"
)

// AuthRequest represents a generic authentication request, abstracting over different protocols.
type AuthRequest struct {
	// Protocol specifies the authentication protocol to be used (e.g., OAuth, SAML).
	Protocol ProtocolType `json:"protocol"`
	// Credentials holds the user's credentials, such as username/password.
	Credentials map[string]string `json:"credentials"`
	// Context provides additional information about the request, like IP address or user agent.
	Context map[string]interface{} `json:"context"`
	// UserID is the unique identifier for the user.
	UserID string `json:"user_id"`
}

// AuthResponse represents a generic authentication response.
type AuthResponse struct {
	// Success indicates whether the authentication was successful.
	Success bool `json:"success"`
	// Token contains the access and refresh tokens if authentication is successful.
	Token *Token `json:"token,omitempty"`
	// User holds the profile of the authenticated user.
	User *User `json:"user,omitempty"`
	// Error provides details if the authentication failed.
	Error *Error `json:"error,omitempty"`
	// Next indicates that a multi-factor authentication step is required.
	Next *MFAChallenge `json:"next,omitempty"`
	// Code is the authorization code generated by the server.
	Code string `json:"code,omitempty"`
	// RedirectURI is the URI to redirect the user to after authorization.
	RedirectURI string `json:"redirect_uri,omitempty"`
	// State is an opaque value used to maintain state between the request and callback.
	State string `json:"state,omitempty"`
	// NextStep indicates the next step in the authentication flow.
	NextStep string `json:"next_step,omitempty"`
	// RequiredMFA lists the MFA methods that can be used to complete the authentication.
	RequiredMFA []string `json:"required_mfa,omitempty"`
}

// AuthResult represents the outcome of an authentication attempt within the domain layer.
type AuthResult struct {
	// Session is the user session created upon successful authentication.
	Session *UserSession
	// Token is the set of tokens (access, refresh) issued.
	Token *Token
	// User is the authenticated user.
	User *User
	// MFAChallenge is populated if an MFA step is required.
	MFAChallenge *MFAChallenge
	// IsMfaRequired is true if the authentication process is not complete and requires an MFA step.
	IsMfaRequired bool
}

// Token represents an access token and related data, typically issued upon successful authentication.
type Token struct {
	// AccessToken is the token used to access protected resources.
	AccessToken string `json:"accessToken"`
	// RefreshToken is used to obtain a new access token.
	RefreshToken string `json:"refreshToken,omitempty"`
	// TokenType indicates the type of token, usually "Bearer".
	TokenType string `json:"tokenType"`
	// ExpiresIn is the lifetime of the access token in seconds.
	ExpiresIn int64 `json:"expiresIn"`
	// IDToken is a JWT that contains identity information, used in OIDC.
	IDToken string `json:"idToken,omitempty"`
}

// Claims represents the standard claims in a JWT, with custom claims for QuantaID.
type Claims struct {
	jwt.RegisteredClaims
	// Scope defines the permissions granted by the token.
	Scope string `json:"scope,omitempty"`
}

// MFAChallenge represents a challenge for multi-factor authentication.
// It is returned when an MFA step is required to complete authentication.
type MFAChallenge struct {
	// MFAProvider specifies the MFA method to be used (e.g., TOTP, SMS).
	MFAProvider AuthMethod `json:"mfaProvider"`
	// ChallengeID is a unique identifier for this specific MFA attempt.
	ChallengeID string `json:"challengeId"`
	// Options contains additional information needed for the challenge (e.g., a phone number mask).
	Options map[string]interface{} `json:"options,omitempty"`
}

// MFAVerificationRequest is used to submit a response to an MFA challenge.
type MFAVerificationRequest struct {
	// ChallengeID is the ID of the challenge being responded to.
	ChallengeID string `json:"challengeId"`
	// Code is the verification code provided by the user (e.g., from an authenticator app).
	Code string `json:"code"`
}

// IdentityProvider represents a configured external identity source, such as a social login provider or an enterprise directory.
type IdentityProvider struct {
	// ID is the unique identifier for the identity provider.
	ID string `json:"id" gorm:"primaryKey"`
	// Name is a user-friendly name for the identity provider.
	Name string `json:"name" gorm:"uniqueIndex;not null"`
	// Type specifies the protocol used by the provider (e.g., OIDC, SAML).
	Type ProtocolType `json:"type" gorm:"not null"`
	// Enabled indicates whether this provider is active.
	Enabled bool `json:"enabled" gorm:"not null;default:true"`
	// Configuration stores the settings required to connect to the provider (e.g., client ID, secret).
	Configuration map[string]interface{} `json:"configuration" gorm:"type:jsonb"`
	// CreatedAt is the timestamp when the provider was created.
	CreatedAt time.Time `json:"createdAt" gorm:"autoCreateTime"`
	// UpdatedAt is the timestamp of the last update.
	UpdatedAt time.Time `json:"updatedAt" gorm:"autoUpdateTime"`
}

// ConnectorConfig holds the configuration for a specific connector instance.
// This is passed to a plugin during its initialization.
type ConnectorConfig struct {
	// InstanceID is a unique ID for this specific instance of the connector.
	InstanceID string `json:"instanceId"`
	// ProviderID is the ID of the identity provider this connector is associated with.
	ProviderID string `json:"providerId"`
	// Config contains the key-value settings for the connector.
	Config map[string]interface{} `json:"config"`
	// PrivateKey is the RSA private key used for signing tokens.
	PrivateKey string `json:"private_key"`
	// RedisURL is the URL of the Redis server.
	RedisURL string `json:"redis_url"`
	// JWTSecret is the secret used for signing JWTs.
	JWTSecret string `json:"jwt_secret"`
}
